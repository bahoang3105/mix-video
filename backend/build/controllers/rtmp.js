"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.publish=void 0;var _fluentFfmpeg=_interopRequireDefault(require("fluent-ffmpeg"));var _models=_interopRequireDefault(require("../models"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}const RTMP=_models.default.rtmp;const publish=async(req,res,next)=>{const{link}=req.body;const linkParams=link.split("/");const room=linkParams[3];const nameStream=linkParams[4];let checkReturn=0;let i=0;let intr;try{const rtmpExists=await RTMP.findOne({where:{room:room,name:nameStream}});if(rtmpExists&&checkReturn===0){return res.status(200).json({success:true,info:`This rtmp already exists. Don't need to republish`})}const command=(0,_fluentFfmpeg.default)().addInput(link).outputOption(["-c copy","-f flv"]).on("error",async(err,stdout,stderr)=>{const rtmpExists=await RTMP.destroy({where:{room:room,name:nameStream}});checkReturn+=1;if(checkReturn<=1){return res.status(404).json({success:false,info:err.message})}}).on("start",async(stdout,stderr)=>{if(checkReturn===0){await RTMP.create({room,name:nameStream})}intr=setInterval(()=>{i++;if(i===5){command.kill()}},1000)}).on("progress",()=>{i=0;checkReturn+=1;if(checkReturn===1){return res.status(200).json({success:true,info:"Republish successfully"})}}).save(`rtmp://localhost:19351/${room}/${nameStream}`).on("end",async(stdout,stderr)=>{await RTMP.destroy({where:{room:room,name:nameStream}})})}catch(err){next(err)}};exports.publish=publish;